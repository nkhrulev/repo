<!DOCTYPE HTML>
<html>
	<head>
		<title>nicols co</title>
		<meta charset='utf-8'/>
		<meta name='viewport' content='width=device-width, initial-scale=1'/>
		<meta name='description' content='Разработка нового, доработка и поддержка уже существующего функционала, обучение программированию на всех возможных языках. Как добиваться успеха в программировании, наслаждаясь жизнью, при этом работая не 12 часов, а головой.'/>
		<meta name='keywords' content='html5, bootstrap, navbar, разработка, angular, dotnet, startup, программирование, администрирование, как сбросить пароль windows 8, как сбросить пароль windows 10, hot to wix error 40, itunes error 4014, itunes error 4013, хайп, блокчейн, биткоин, pivot, mdx, window functions'/>
		<meta name="google-site-verification" content="Qlu6INt4gikwmVM8uSMy7wEV2NbAcxlL-ZgCuUPrJ-Y" />
		<meta name="yandex-verification" content="7e246d1d1e188569" />
		<link rel="shortcut icon" href="../../../../favicon.ico">
		<link rel="icon" type="image/png" href="../../../../favicon.png" sizes="32x32">
		<link rel="apple-touch-icon" href="../../../../favicon.png" sizes="32x32">
		<link href='../../../css/css.css' rel='stylesheet'/>
		<link href='../../../css/bootstrap.css' rel='stylesheet'/>
		<script src='../../../js/js.js'></script>
	</head>
	<body>
		<div class='container body-content' id='body-content'>
			<nav class='navbar navbar-expand-lg navbar-light bg-white sticky-top border-bottom'>
				<button class='navbar-toggler navbar-toggler-right' type='button' onclick='load_nav()' data-toggle='collapse' data-target='.navbar-collapse' aria-controls='navbar-collapse' aria-expanded='false' aria-label='Toggle navigation'><span class='navbar-toggler-icon'></span></button>
				<div>
					<a class='navbar-brand icon fa-home' href='../../../index.html'></a>
					<a class='navbar-brand' href='#' onclick='load_lang()'><span class='flag en' id='flag'>flag en</span></a>
				</div>
				<div class='collapse navbar-collapse' id='navbar-collapse'>
					<ul class='navbar-nav mr-auto mt-2 mt-md-0'>
						<li class='nav-item'><a class='nav-link' href='../about.html'>About</a></li>
						<li class='nav-item'><a class='nav-link' href='../contact.html'>Contact</a></li>
						<li class='nav-item'><a class='nav-link' href='../work.html'>Working out</a></li>
						<li class='nav-item'><a class='nav-link' href='../literature.html'>Literature</a></li>
					</ul>
					<form class='form-inline my-2 my-lg-0'>
						<input class='form-control mr-sm-2' type='search' placeholder='Search' id='search_text'/>
						<button class='btn btn-outline-success my-2 my-sm-0' type='button' onclick='search()' id='search_button'>Search</button>
					</form>
				</div>
			</nav>
			
			<script>comeback();</script>
			
			<h3>How to create Excel file from sql server.</h3><pre>EXEC sp_configure 'show advanced options', 1<br/>GO<br/><br/>EXEC sp_configure 'xp_cmdshell', 1<br/>GO<br/><br/>RECONFIGURE<br/>GO<br/><br/>DECLARE @sql varchar(300)<br/>SELECT @sql = 'bcp \"use TSQL2016; select ''Id'',''DateWrite'',''Euro'',''Brent'' union all select cast(Id as varchar(100)), cast(DateWrite as varchar(100)), cast(Euro as varchar(100)), cast(Brent as varchar(100)) from Euro_Brent\" queryout G:\\Excel.csv -c -t, -T -S' + @@servername<br/>EXEC master..xp_cmdshell @sql<br/><br/>-- Example query<br/>use TSQL2016;<br/>select 'Id', 'DateWrite', 'Euro', 'Brent'<br/>union all<br/>select cast(Id as varchar(100)), cast(DateWrite as varchar(100)), cast(Euro as varchar(100)), cast(Brent as varchar(100)) <br/>from Euro_Brent</pre><table border='1'><tr><th>Id</th><th>DateWrite</th><th>Euro</th><th>Brent</th></tr><tr><td>1</td><td>2017-12-15 10:00:00</td><td>69.3</td><td>63.42</td></tr><tr><td>2</td><td>2017-12-15 10:10:00</td><td>69.43</td><td>63.47</td></tr><tr><td>3</td><td>2017-12-15 10:20:00</td><td>69.49</td><td>63.46</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr><tr><td>39</td><td>2017-12-15 16:20:00</td><td>69.48</td><td>63.31</td></tr><tr><td>40</td><td>2017-12-15 16:30:00</td><td>69.48</td><td>63.35</td></tr></table><script>publish_date();</script><hr /><h3>Column name or number of supplied values does not match table definition.</h3><p>If you get this error, and the matching of the columns matches the source and inserted tables, use the following syntax to avoid it:</p><pre>select *into new_table_name from source_table_name where [date] between '20160101' and '20161231'</pre><script>publish_date();</script><hr /><h3>How to delete active processes for all users ?.</h3><pre>declare @dbname varchar(100)<br />declare @query varchar(max)<br />set @query = ''<br />set @dbname = 'db_name'<br />select @query = coalesce(@query, ',') + 'kill ' + convert(varchar, spid) + '; '<br />from sys.sysprocesses where dbid = db_id(@dbname)<br />if len(@query) > 0 begin<br />	exec(@query)<br />end</pre><script>publish_date();</script><hr /><h3>Best practices.</h3><p>The best motivation from all that I've seen.</p><pre>declare @i int = 365;<br />select power(0.99, @i) [min_motivation], power(1.01, @i) [max_motivation]</pre><p><b>Output:</b></p><table border='1'><tr><th>min_motivation</th><th>max_motivation</th></tr><tr><td>0.03</td><td>37.78</td></tr></table><script>publish_date();</script><hr /><h3>Max value data type bigint.</h3><p>How to get the maximum value of type bigint:</p><pre>select power(2., 64) - 1 as maxValueBigInt</pre><script>publish_date();</script><hr /><h3>Offset rows fetch.</h3><p>If you want to skip the <b>n</b>-th number of records, and get the following <b>m</b> entries, then use the following syntax:</p><pre>declare @n int = 0;<br />declare @m int = 5;<br />select *from (<br />	values (0), (1), (2), (3), (4), (5), (6), (7), (8), (9), (10), (11), (12), (13), (14), (15), (16), (17), (18), (19), (20)<br />) as t(id)<br />order by id<br />offset @n rows fetch first @m rows only</pre><script>publish_date();</script><hr /><h3>Unpivot:</h3><p>If you need to make a transposition (rows replaced by columns) of the table, take the following code as an example and use the <b>PIVOT</b> operator. For the reverse implementation of the transposition (columns to replace rows), the <b>UNPIVOT</b> operator is used.</p><pre>select IdKey, [Type], summ, [01], [02], [03], [04], [05], [06], [07], [08], [09], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31]<br />from (<br />	values(1, 'TYPE', 10.125, 198.3905194, 198.3905194, 332.8376936, 347.1834089, 459.8195238, 339.3698885, 521.4020027, 186.6064438, 349.5779158, 468.5718135, 466.1038878, 466.1038878, 477.7564851, 498.1261596, 201.9377443, 486.0331927, 545.2503678, 452.2873126, 512.7663862, 549.3981369, 462.8785397, 391.3860639, 595.2856341, 396.8570894, 595.2856341, 595.2856341, 541.3424301, 594.5881906, 396.8570894, 575.4633152, 396.8570894)<br />) as t(IdKey, [Type], summ, [01], [02], [03], [04], [05], [06], [07], [08], [09], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31])<br /><br /></pre><p><b>RESULT</b></p><table border='1'><tr><th>IdKey</th><th>Type</th><th>summ</th><th>01</th><th>...</th><th>31</th></tr><tr><td>1</td><td>TYPE</td><td>10.125</td><td>198.390</td><td>...</td><td>396.857</td></tr></table><br /><pre>declare @date date = getdate();<br />select IdKey, [Type], concat(FORMAT(@date, 'yyMM'), DateKey) DateKey, Quantity, Summ<br />from (<br />	values(1, 'TYPE', 10.125, 198.390, 198.390, 332.837, 347.183, 459.819, 339.369, 521.402, 186.606, 349.577, 468.571, 466.103, 466.103, 477.756, 498.126, 201.937, 486.033, 545.250, 452.287, 512.766, 549.398, 462.878, 391.386, 595.285, 396.857, 595.285, 595.285, 541.342, 594.588, 396.857, 575.463, 396.857)<br />) as t(IdKey, [Type], summ, [01], [02], [03], [04], [05], [06], [07], [08], [09], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31])<br />UNPIVOT (<br />    Quantity<br />    FOR DateKey IN ([01], [02], [03], [04], [05], [06], [07], [08], [09], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31])<br />) UNPIV<br />order by IdKey</pre><p><b>RESULT</b></p><table border='1'><tr><th>IdKey</th><th>Type</th><th>DateKey</th><th>Quantity</th><th>Summ</th></tr><tr><td>1</td><td>TYPE</td><td>171001</td><td>198.390</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171002</td><td>198.390</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171003</td><td>332.837</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171004</td><td>347.183</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171005</td><td>459.819</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171006</td><td>339.369</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171007</td><td>521.402</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171008</td><td>186.606</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171009</td><td>349.577</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171010</td><td>468.571</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171011</td><td>466.103</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171012</td><td>466.103</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171013</td><td>477.756</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171014</td><td>498.126</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171015</td><td>201.937</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171016</td><td>486.033</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171017</td><td>545.250</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171018</td><td>452.287</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171019</td><td>512.766</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171020</td><td>549.398</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171021</td><td>462.878</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171022</td><td>391.386</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171023</td><td>595.285</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171024</td><td>396.857</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171025</td><td>595.285</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171026</td><td>595.285</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171027</td><td>541.342</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171028</td><td>594.588</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171029</td><td>396.857</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171030</td><td>575.463</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171031</td><td>396.857</td><td>10.125</td></tr></table><script>publish_date();</script><hr /><h3>Convert MDX to flat table.</h3><p>How to deploy mdx query in a flat table ?.</p><pre>DECLARE @query VARCHAR(MAX);<br />DECLARE @mdxquery VARCHAR(MAX);<br /><br />SET @mdxquery = ' YOUR_MDX_QUERY ';<br /><br />SET @query = '<br />	WITH MDX AS (<br />		SELECT<br />			ListColumns<br />		FROM OPENQUERY(YOUR_SERVER_NAME, ''' + @mdxquery + ''')<br />	)<br /><br />	SELECT ListColumns FROM MDX<br />';<br /><br />EXEC (@query);</pre><script>publish_date();</script><hr /><h3>Pivot:</h3><p>Write a script to sample sales amounts (sales) with the following conditions:<br />1. Display sales amounts for the period specified by the user;<br />2. In the line to output the name of the goods, the amount of sales for the specified date, the sampling period may change, the number of columns in the final report is not known in advance.<br />Data output without time. In the final query output columns: Product name, date1, date2, etc.</p><pre>--Table [ref_goods]:<br />select *from (<br />	values<br />		(1, 'Ballpoint pen black'),<br />		(1, 'Ballpoint pen blue'),<br />		(1, 'Gel black handle'),<br />		(1, 'Gel pen blue'),<br />		(2, 'Pencil blue'),<br />		(2, 'Pencil green'),<br />		(2, 'Pencil Red')<br />) as ref_goods(id, good_name)<br /><br />--Insert into Table [sales]:<br />declare @StartDate datetime<br />declare @EndDate datetime<br />declare @Good int<br />declare @Amount numeric(18, 2)<br /><br />set @StartDate = '20120101'<br />set @EndDate = getdate()<br />set @Good = 1<br />set @Amount = 15.12<br /><br />while @StartDate < @EndDate begin<br />	insert into sales<br />	select @Good, @StartDate, @Amount<br /><br />	set @StartDate = dateadd(hour, 4, @StartDate)<br />	set @Good = case when @Good = 7 then 1 else @Good + 1 end<br />	set @Amount = case when @Amount > 100000 then 15.12 else @Amount + 21.14 end<br />end<br /><br />--Strictly speaking, the request itselfset language british;<br />declare @StartDate datetime = '20120101';<br />declare @EndDate datetime = getdate();<br /><br />declare @cols nvarchar(max)<br />select @cols = coalesce(@cols + ',[' + convert(nvarchar, s_date, 104) + ']', '[' + convert(nvarchar, s_date, 104) + ']')<br />			   from (select distinct cast(s_date as date) s_date from sales where s_date between @StartDate and @EndDate) PV<br />			   order by s_date<br /><br />declare @query nvarchar(max)<br />set @query = '<br />				select *from (<br />					select r.good_name, sum(s.amount) [amount], cast(s_date as date) s_date<br />					from sales s<br />						join ref_goods r on s.id_good = r.id<br />					where s_date between ''' + convert(nvarchar, @StartDate, 104) + ''' and ''' + convert(nvarchar, @EndDate, 104) + '''<br />					group by r.good_name, s_date<br />				) x<br />				pivot (<br />					sum(amount)<br />					for s_date in (' + @cols + ')<br />				) p<br />			'<br /><br />exec SP_EXECUTESQL @query</pre><script>publish_date();</script><hr /><h3>What is an index in T-SQL ?.</h3><p>Index is a database object created to improve the performance of data retrieval. The index is similar to the alphabetical index in the book. If we need to find the definition of a function in T-SQL, we will do the following:<br /><br />1. Find the alphabetical index in the book (it is usually at the end of the book);<br />2. Then find the desired function, for example, select (page 52);<br />3. We pass on this page, and read about the function select.<br /><br />Indices are clustered and nonclustered. Here's how the index works in a nutshell.</p><script>publish_date();</script><hr /><h3>Optimizing the query.</h3><p>Cited two queries, the result of the sample is the same.<br />One is performed in 40 seconds, the other in 4 seconds, where is the catch ?. See below:<br /><br /><b>Query:</b></p><pre>select <br />	isnull(_all.rdc, plans.rdc) rdc, <br />	isnull(_all.distributor, '') distributor, <br />	isnull(_all.sv, '') sv, <br />	isnull(_all.etp, '') etp, <br />	isnull(_all.subject, plans.subject) subject, <br />	isnull(_all.cnt_all, 0) cnt_all, <br />	isnull(_period.cnt_period, 0) cnt_period, <br />	isnull(plans.pln,0) reestr_tt <br />from (<br />	select rdc, distributor, sv, etp, subject, count(id) cnt_all from #TT<br />	where isnull(@rdc, rdc) = rdc <br />	and isnull(@subject, subject) = subject<br />	and distributor = isnull(@company, distributor)<br />	group by rdc, distributor, sv, etp, subject<br />) _all join (<br />	select rdc, distributor, sv, etp, subject, count(id) cnt_period from #TT<br />	where dtCreate between isnull(@beginDate, '19000101') and isnull(@endDate, '21500101')<br />	and isnull(@rdc, rdc) = rdc <br />	and isnull(@subject, subject) = subject<br />	and distributor = isnull(@company, distributor)<br />	group by rdc, distributor, sv, etp, subject<br />) _period<br />on <br />	_all.distributor = _period.distributor and <br />	_all.etp = _period.etp and<br />	_all.subject = _period.subject and<br />	_period.sv = _all.sv<br />right join (<br />	select upl.rdc, p.subject, sum(p.count) pln from<br />	ReportPlan p join (select distinct rdc, subject from upload where isnull(@rdc, rdc) = rdc and isnull(@subject, subject) = subject) upl on p.subject = upl.subject and upl.rdc is not null<br />	group by upl.rdc, p.subject<br />) plans on plans.subject = _all.subject<br />order by _all.rdc, _all.subject<br /></pre><p><b>Result:</b></p><pre>SQL Server Execution Times:			CPU time = 0 ms,  elapsed time = 0 ms.<br />SQL Server parse and compile time:  		CPU time = 859 ms, elapsed time = 950 ms.<br />SQL Server Execution Times:			CPU time = 0 ms,  elapsed time = 0 ms.<br /><br />(1026 row(s) affected)<br />Table 'Workfile'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br />Table 'Worktable'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br />Table 'ReportPlan'. Scan count 1, logical reads 144, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br />Table 'upload'. Scan count 1, logical reads 745, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br />Table '#TT'. Scan count 2, logical reads 1524, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br /><br />(1 row(s) affected)<br /><br />SQL Server Execution Times:			CPU time = 23188 ms,  elapsed time = 45460 ms.<br />SQL Server parse and compile time:		CPU time = 0 ms, elapsed time = 0 ms.<br />SQL Server Execution Times:			CPU time = 0 ms,  elapsed time = 0 ms.<br /></pre><p><b>Optimized query:</b></p><pre>select <br />	isnull(_all.rdc, plans.rdc) rdc, <br />	_all.distributor, <br />	_all.sv, <br />	_all.etp, <br />	isnull(_all.subject, plans.subject) subject, <br />	_all.cnt_all, <br />	_period.cnt_period, <br />	plans.pln reestr_tt <br />from (<br />	select upl.rdc, p.subject, sum(p.count) pln from<br />	ReportPlan p join (<br />		select distinct rdc, subject from sensus_etp_upload where isnull(@rdc, rdc) = rdc and isnull(@subject, subject) = subject<br />	) upl on p.subject = upl.subject and upl.rdc is not null<br />	group by upl.rdc, p.subject<br />) plans left join (<br />	select rdc, distributor, sv, etp, subject, count(id) cnt_all from #TT<br />	where isnull(@rdc, rdc) = rdc <br />	and isnull(@subject, subject) = subject<br />	and distributor = isnull(@company, distributor)<br />	group by rdc, distributor, sv, etp, subject<br />) _all on plans.subject = _all.subject<br />left join (<br />	select rdc, distributor, sv, etp, subject, count(id) cnt_period from #TT<br />	where dtCreate between isnull(@beginDate, '19000101') and isnull(@endDate, '21500101')<br />	and isnull(@rdc, rdc) = rdc <br />	and isnull(@subject, subject) = subject<br />	and distributor = isnull(@company,distributor)<br />	group by rdc, distributor, sv, etp, subject<br />) _period<br />on <br />	_all.distributor = _period.distributor and <br />	_all.etp = _period.etp and<br />	_all.subject = _period.subject and<br />	_period.sv = _all.sv<br />order by _all.rdc, _all.subject<br /></pre><p><b>Optimized result:</b></p><pre>SQL Server Execution Times:			CPU time = 0 ms,  elapsed time = 0 ms.<br />SQL Server parse and compile time:		CPU time = 843 ms, elapsed time = 849 ms.<br />SQL Server Execution Times:			CPU time = 0 ms,  elapsed time = 0 ms.<br /><br />(995 row(s) affected)<br />Table 'Worktable'. Scan count 156, logical reads 6600, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br />Table '#TT'. Scan count 2, logical reads 1556, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br />Table 'upload'. Scan count 1, logical reads 1471, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br />Table 'ReportPlan'. Scan count 1, logical reads 144, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br /><br />(1 row(s) affected)<br /><br />SQL Server Execution Times:			CPU time = 2172 ms,  elapsed time = 2660 ms.<br />SQL Server parse and compile time:		CPU time = 0 ms, elapsed time = 0 ms.<br />SQL Server Execution Times:			CPU time = 0 ms,  elapsed time = 0 ms.</pre><script>publish_date();</script><hr /><h3>Convert DistinctBy to T-SQL.</h3><p>At the moment, I'm developing and supporting an MVC type project and I often have to deal with rewriting C# code on T-SQL. For an example today, let's take a look at the C# DistinctBy() method. I took the array of data from the last article:</p><pre>// C#<br />data.DistinctBy(x => x.TmId).OrderBy(x => x.Points)<br /><br />// T-SQL<br />select *from(<br />	select Rm as Employee, (OutPoint + IncrementPoint + ArkbPoint + SdzPoint + RoutePoint + SchedulePoint) / 6 as ball, row_number() over (partition by RmId order by Id) rn from #tmp<br />) t where rn = 1</pre><script>publish_date();</script><hr /><h3>Convert LinqToSql to T-SQL.</h3><p>Friends, all of a good day, not long ago I faced the task of rewriting linq to t-sql, everything would be fine, but there was one thing: you had to rewrite the C# method Array.FindIndex() on T-SQL. And this is how it is implemented.</p><pre>// C#<br />List<Rating2> data =<br />	Context.Rating.Where(x => x.CreatedDate.Month == date.Month && x.CreatedDate.Year == date.Year && x.CreatedDate.Day == date.Day).ToList();<br /><br />List<Rating> ratings = data.Select(<br />	x => new Rating<br />	{<br />		Id = x.Id,<br />		Rdc = x.Rdc,<br />		RdcId = x.RdcId,<br />		Distributor = x.Distributor,<br />		DistributorId = x.DistributorId,<br />		EtpId = x.EtpId,<br />		Etp = x.Etp,<br />		RmId = x.RmId,<br />		Rm = x.Rm,<br />		Sv = x.Sv,<br />		SvId = x.SvId,<br />		Tm = x.Tm,<br />		TmId = x.TmId,<br />		OutPoint = 2 * (Array.FindIndex(data.OrderByDescending(o => o.OutMass).ToArray(), a => a.EtpId == x.EtpId) + 1),<br />		IncrementPoint = 2 * (Array.FindIndex(data.OrderByDescending(o => o.PrevOutMass).ToArray(), a => a.EtpId == x.EtpId) + 1),<br />		ArkbPoint = Array.FindIndex(data.OrderByDescending(o => o.CountAtt).ToArray(), a => a.EtpId == x.EtpId) + 1,<br />		SdzPoint = Array.FindIndex(data.OrderByDescending(o => o.AvgOrdersPerDay).ToArray(), a => a.EtpId == x.EtpId) + 1,<br />		RoutePoint = Array.FindIndex(data.OrderByDescending(o => o.PenaltyRoute).ToArray(), a => a.EtpId == x.EtpId) + 1,<br />		SchedulePoint = Array.FindIndex(data.OrderByDescending(o => o.PenaltyWorktime).ToArray(), a => a.EtpId == x.EtpId) + 1,<br />		ObservanceRoute = x.PenaltyRoute,<br />		MaintenanceSchedule = x.PenaltyWorktime,<br />		Sdz = x.AvgOrdersPerDay,<br />		FactOutLast = x.PrevOutMass,<br />		PlanPercentArkb = x.CountAtt,<br />		FactOut = x.FactOut,<br />		PlanOut = x.PlanOut,<br />		FactArkb = x.FactArkb,<br />		PlanArkb = x.PlanArkb,<br />		PlanPercentOut = x.OutMass,<br />		IncrementRate = x.IncrementRate<br />}).ToList();<br /><br />// T-SQL<br />select<br />	Id,<br />	Rdc,<br />	RdcId,<br />	Distributor,<br />	DistributorId,<br />	EtpId,<br />	Etp,<br />	RmId,<br />	Rm,<br />	Sv,<br />	SvId,<br />	Tm,<br />	TmId,<br />	2 * cast(row_number() over(order by OutMass desc, Id) as int) OutPoint,<br />	2 * cast(row_number() over(order by PrevOutMass desc, Id) as int) IncrementPoint,<br />	cast(row_number() over(order by CountAtt desc, Id) as int) ArkbPoint,<br />	cast(row_number() over(order by AvgOrdersPerDay desc, Id) as int) SdzPoint,<br />	cast(row_number() over(order by PenaltyRoute desc, Id) as int) RoutePoint,<br />	cast(row_number() over(order by PenaltyWorktime desc, Id) as int) SchedulePoint,<br />	PenaltyRoute as ObservanceRoute,<br />	PenaltyWorktime as MaintenanceSchedule,<br />	AvgOrdersPerDay as Sdz,<br />	PrevOutMass as FactOutLast,<br />	CountAtt as PlanPercentArkb,<br />	FactOut,<br />	PlanOut,<br />	FactArkb,<br />	PlanArkb,<br />	OutMass as PlanPercentOut,<br />	IncrementRate<br />from Rating<br />where isnull(@load_date, CreatedDate) = CreatedDate<br />order by Id</pre><script>publish_date();</script><hr /><h3>Null value is eliminated by an aggregate or other SET operation.</h3><p>As that one of these days received the given error, in the stored procedures. The example showed how you can get rid of it.</p><pre>--Before:<br />select sum(col2) sum_col2 from(<br />	select *from (<br />		values<br />			( 1, NULL, 3 ),<br />            ( 1, 2, 3 )<br />	) as d(col1, col2, col3)<br />) t<br /><br /><b>result:</b><br />sum_col2<br />2<br />Warning: Null value is eliminated by an aggregate or other SET operation.<br />(1 row(s) affected)<br /><br />--After:<br />select sum(isnull(col2, 0)) sum_col2 from(<br />	select *from (<br />		values<br />			( 1, NULL, 3 ),<br />            ( 1, 2, 3 )<br />	) as d(col1, col2, col3)<br />) t<br /><br /><b>result:</b><br />sum_col2<br />2<br />(1 row(s) affected)</pre><script>publish_date();</script><hr /><h3>Jobs.</h3><p>In this post, I would like to give you an example of a query that displays a list of all Jobs with respect to the desired name of tables, views, stored procedures, functions, and many other sql objects.</p><pre>select name [JobName], step_name, *<br />from msdb.dbo.sysjobsteps s<br />	join msdb.dbo.sysjobs o on o.job_id = s.job_id<br />where command like '%contains%'</pre><p>In the query \"contains\" - your data for searching (it can be either tables or procedures, as well as functions and other sql objects). Below is an example of a query that returns real data.</p><pre>select name [JobName], step_name, *<br />from msdb.dbo.sysjobsteps s<br />	join msdb.dbo.sysjobs o on o.job_id = s.job_id<br />where command like '%server%'<br /></pre><script>publish_date();</script><hr /><h3>Importing and exporting data.</h3><p>In this post I want to share with you the experience of exporting data from Excel to MS SQL SERVER.<br /><br />Suppose there is an empty dbo.Coords table.<br />Also there is an Excel file with some data.<br />First, start the \"Sql Server Import and Export Data\", select the \"File Location\" in the <b> Data source </b> drop-down list: \"Microsoft Excel\" in the <b> Excel file path </b> entry.<br />In the <b> Destination </b>: select \"SQL Server Native Client 11.0\", select the database from the list ...<br />Copy the data from the Excel file to the table specified in the next step.<br />The Excel file is called Coords.xlsx, the table is called dbo.Coords.<br />Let's see if we've chosen everything correctly.<br />And let's start, perhaps.<br />The export is complete.<br />Do not forget to check that the data in the dbo.Coords table is updated.</p><script>publish_date();</script><hr /><h3>Default Database.</h3><p>Often, when connecting to the DataBase Engine component, the \"master\" database is installed by default. We will correct this situation in this post. All we need is to select the</p><pre>[File] -> [Connect Object Explorer] -> [Options >>] -> In the [Connection to] tab, select [&lt;Browse server ...&gt;] -> Reply in the affirmative, to view the databases -> And select from the list the desired database.</pre><script>publish_date();</script><hr /><h3>Locks.</h3><p>With the \"with (nolock)\" hint, locks still appear. Many young developers at one stage of their career begin to use hint with (nolock) wherever they like, because with this hint, queries run faster. This is not always a bad thing, but it can be accompanied by unexpected actions. When the query accesses any table, say [YourServerName].[YourNameDb].[Dbo].[Orders], even with the nolock hint, you impose a schema stability lock (Sch-S). Nobody can make changes to this table or its indexes until your request is completed. This does not seem to be a significant problem until you need to delete the index, but you can not do this because people constantly work with the given table, being in full confidence that they do not create any problems, as a result they use hint with (nolock). There is no \"silver bullet\", but worth looking at the isolation levels of SQL Server.</p><script>publish_date();</script><hr /><h3>IntelliSense.</h3><p>Today I noticed that I do not have IntelliSense running in sqlms (sql server management studio 2014).<br />It ceased to work because of the removal of sql Assistant.<br /><br />This problem is solved very easily:</p><pre>Choose: Tools -> Options -> Text Editor -> Transact-SQL -> IntelliSense -> Enable IntelliSense</pre><script>publish_date();</script><hr /><h3>Cube.</h3><p>To connect to the OLAP information analysis system, you need to perform a number of the following steps:<br />1. Start the Microsoft Excel product that is included in the Microsoft Office suite.<br />2. In the Excel menu, go to the \"Data\" tab.<br />3. In the \"Obtain external data\" panel, select \"From other sources\" - \"From analytics services\".<br />4. In the dialog box that appears, in the \"Server name\" field enter the server name: \"your-server-name\". Leave the remaining parameters unchanged. Click the \"Next\" button.<br />5. In the \"Data Connection Wizard\" dialog box, you must select the database \"your_db_name\", in the cube selection panel - the cube \"your_cube_name\". Click \"Next\".<br />6. In the \"Save Data Connection and Shutdown File\" dialog box, agree with the proposed options and click \"Finish\".<br />7. In the \"Import Data\" dialog box, you can select the cell that will be the top-left corner of the summary table. Click the \"OK\" button.<br />8. The interface with the analytical system \"your_cube_name\" is a standard Microsoft Excel interface for working with pivot tables. The area of the pivot table itself is displayed in the left corner.</p><script>publish_date();</script><hr /><h3>Sql Trees.</h3><p>An example of a tree in t-sql.<br />I'll quote the query and then try to guess what it does, there will be questions to address them <a href='mailto:hru91nik@mail.ru'>here</a>.<br />The code is shown below.</p><pre>with Employees as (<br />	select *from (<br />		values<br />		   (1,  NULL, 'David'  , $10000.00),<br />		   (2,  1,    'Eitan'  ,  $7000.00),<br />		   (3,  1,    'Ina'    ,  $7500.00),<br />		   (4,  2,    'Seraph' ,  $5000.00),<br />		   (5,  2,    'Jiru'   ,  $5500.00),<br />		   (6,  2,    'Steve'  ,  $4500.00),<br />		   (7,  3,    'Aaron'  ,  $5000.00),<br />		   (8,  5,    'Lilach' ,  $3500.00),<br />		   (9,  7,    'Rita'   ,  $3000.00),<br />		   (10, 5,    'Sean'   ,  $3000.00),<br />		   (11, 7,    'Gabriel',  $3000.00),<br />		   (12, 9,    'Emilia' ,  $2000.00),<br />		   (13, 9,    'Michael',  $2000.00),<br />		   (14, 9,    'Didi'   ,  $1500.00)<br />	) as d(empid, mgrid, empname, salary)<br />),<br />EmpsRN as (<br />	select *, row_number() over(partition by mgrid order by empname, empid) as n<br />	from Employees<br />),<br />EmpsPath as (<br />	 select empid, empname, salary, 0 AS lvl, cast(0x as varbinary(max)) as sortpath<br />	 from Employees<br />	 where mgrid is null<br />	 union all<br />	 select C.empid, C.empname, C.salary, P.lvl + 1, P.sortpath + cast(n as binary(2))<br />	 from EmpsPath as P<br />		join EmpsRN as C on C.mgrid = P.empid<br />)<br />select empid, salary, replicate(' | ', lvl) + empname as empname<br />from EmpsPath<br />order by sortpath;<br /></pre><p>The example is taken from Itzik Ben-Ghana's book \"Microsoft SQL Server 2012. High-performance T-SQL code.\" Window functions.\"</p><script>publish_date();</script><hr /><h3>Window functions.</h3><p>Pros of window functions.<br />I will not comment here, just look at the following code and you will understand everything yourself. If you still have any questions, you can address them <a href='mailto:hru91nik@mail.ru'>here</a>.<br />The following are both alternatives and window functions.</p><pre>-- 1.1. without window func<br />with CustAggregates as(<br />	select custid, sum(val) as sumval, avg(val) as avgval<br />	from Sales.OrderValues<br />	group by custid<br />),<br />GrandAggragates as(<br />	select sum(val) as sumval, avg(val) as avgval<br />	from Sales.OrderValues<br />)<br />select o.orderid, o.custid, o.val,<br />	cast(100 * o.val / ca.sumval as numeric(5, 2)) as pctcust,<br />	o.val - ca.avgval as diffcust,<br />	cast(100 * o.val / ga.sumval as numeric(5, 2)) as pctall,<br />	o.val - ga.avgval as diffall<br />from Sales.OrderValues as o<br />	join CustAggregates as ca on o.custid = ca.custid<br />	cross join GrandAggragates as ga;<br /><br />-- 1.2. without window func<br />select orderid, custid, val,<br />	cast(100 * val / (<br />		select sum(o2.val)<br />		from Sales.OrderValues as o2<br />		where o2.custid = o1.custid<br />  ) as numeric(5, 2)) as pctcust,<br />	val - (<br />		select avg(o2.val)<br />		from Sales.OrderValues as o2<br />		where o2.custid = o1.custid<br />  ) diffcust,<br />	cast(100 * val / (<br />		select sum(o2.val)<br />		from Sales.OrderValues as o2) as numeric(5, 2)) as pctall,<br />	val - (<br />		select avg(o2.val)<br />		from Sales.OrderValues as o2<br />		where o2.custid = o1.custid<br />  ) diffall<br />from Sales.OrderValues as o1<br /><br />-- 1.3. with window func<br />select orderid, custid, val,<br />	cast(100 * val / sum(val) over(partition by custid) as numeric(5, 2)) as pctcust,<br />	val - avg(val) over(partiotion by custid) diffcust,<br />	cast(100 * val / sum(val) over() as numeric(5, 2)) as pctall,<br />	val - avg(val) over() diffall<br />from Sales.OrderValues;<br /><br />-- 1.4. without window func<br />select min(col1) as start_range, max(col1) as end_range<br />from (<br />	select col1,(<br />		select min(b.col1)<br />		from dbo.T1 as b<br />		where b1.col1 >= a.col1<br />			and not exists(<br />			select *<br />			from dbo.T1 as c<br />			where c.col1 = b.col1<br />		)<br />	) as grp<br />	from dbo.T1 as a<br />) as d<br />group by grp;<br /><br />-- 1.5. with window func<br />select min(col1) as start_range, max(col1) as end_range<br />from (<br />	select col1,<br />	col1 - row_number() over(order by col1) as grp<br />	from dbo.T1<br />) as d<br />group by grp;</pre><script>publish_date();</script><hr /><h3>Request with two or more servers.</h3><p>One of these days the task fell, to unite two tables from different servers. So on t-sql the problem was solved as follows:</p><pre>select *from [srvName].[dbName].[shemaName].[tableName]<br />union all<br />select *from [srvNameOld].[dbName].[shemaName].[tableName]</pre><p>Thus we get the result set from two different servers, it's worth noting that the tables in my case are identical.</p><script>publish_date();</script><hr /><h3>For xml path.</h3><p>In this article I would like to share with you the following tool. Suppose there is a sample represented by the following code:</p><pre>with T1 as (<br />	select *from (<br />		values<br />			(1, 'A'),<br />			(2, 'B'),<br />			(3, 'C'),<br />			(4, 'D'),<br />			(5, 'E')<br />	) as d(id, word)<br />) select *from T1</pre><p>The query has the following form:</p><pre>select *from T1;</pre><p>The task is to collect the rows in one result field, for example for the field 'word' the result should be the following 'A, B, C, D, E'. In t-sql there is the following construction: <b>for xml path ('')</b>. It will be necessary for us to obtain this result. The query will look like this:</p><pre>select word + ', ' from T1 for xml path('');</pre><script>publish_date();</script>
			
			<script>foo();</script>
		</div>
	</body>
</html>