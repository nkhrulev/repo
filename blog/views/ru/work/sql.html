<!DOCTYPE HTML>
<html>
	<head>
		<title>nicols co</title>
		<meta charset='utf-8'/>
		<meta name='viewport' content='width=device-width, initial-scale=1'/>
		<meta name='description' content='Разработка нового, доработка и поддержка уже существующего функционала, обучение программированию на всех возможных языках. Как добиваться успеха в программировании, наслаждаясь жизнью, при этом работая не 12 часов, а головой.'/>
		<meta name='keywords' content='html5, bootstrap, navbar, разработка, angular, dotnet, startup, программирование, администрирование, как сбросить пароль windows 8, как сбросить пароль windows 10, hot to wix error 40, itunes error 4014, itunes error 4013, хайп, блокчейн, биткоин, pivot, mdx, window functions'/>
		<meta name="google-site-verification" content="Qlu6INt4gikwmVM8uSMy7wEV2NbAcxlL-ZgCuUPrJ-Y" />
		<meta name="yandex-verification" content="7e246d1d1e188569" />
		<link rel="shortcut icon" href="../../../../favicon.ico">
		<link rel="icon" type="image/png" href="../../../../favicon.png" sizes="32x32">
		<link rel="apple-touch-icon" href="../../../../favicon.png" sizes="32x32">
		<link href='../../../css/css.css' rel='stylesheet'/>
		<link href='../../../css/bootstrap.css' rel='stylesheet'/>
		<script src='../../../js/js.js'></script>
	</head>
	<body>
		<div class='container body-content' id='body-content'>
			<nav class='navbar navbar-expand-lg navbar-light bg-white sticky-top border-bottom'>
				<button class='navbar-toggler navbar-toggler-right' type='button' onclick='load_nav()' data-toggle='collapse' data-target='.navbar-collapse' aria-controls='navbar-collapse' aria-expanded='false' aria-label='Toggle navigation'><span class='navbar-toggler-icon'></span></button>
				<div>
					<a class='navbar-brand icon fa-home' href='../../../index.html'></a>
					<a class='navbar-brand' href='#' onclick='load_lang()'><span class='flag ru' id='flag'>flag ru</span></a>
				</div>
				<div class='collapse navbar-collapse' id='navbar-collapse'>
					<ul class='navbar-nav mr-auto mt-2 mt-md-0'>
						<li class='nav-item'><a class='nav-link' href='../about.html'>Обо мне</a></li>
						<li class='nav-item'><a class='nav-link' href='../contact.html'>Контакты</a></li>
						<li class='nav-item'><a class='nav-link' href='../work.html'>Разработка</a></li>
						<li class='nav-item'><a class='nav-link' href='../literature.html'>Литература</a></li>
					</ul>
					<form class='form-inline my-2 my-lg-0'>
						<input class='form-control mr-sm-2' type='search' placeholder='Поиск' id='search_text'/>
						<button class='btn btn-outline-success my-2 my-sm-0' type='button' onclick='search()' id='search_button'>Поиск</button>
					</form>
				</div>
			</nav>
			
			<script>comeback();</script>
			
			<h3>Как создать Excel файл средствами sql server.</h3><pre>EXEC sp_configure 'show advanced options', 1<br/>GO<br/><br/>EXEC sp_configure 'xp_cmdshell', 1<br/>GO<br/><br/>RECONFIGURE<br/>GO<br/><br/>DECLARE @sql varchar(300)<br/>SELECT @sql = 'bcp "use TSQL2016; select ''Id'',''DateWrite'',''Euro'',''Brent'' union all select cast(Id as varchar(100)), cast(DateWrite as varchar(100)), cast(Euro as varchar(100)), cast(Brent as varchar(100)) from Euro_Brent" queryout G:\\Excel.csv -c -t, -T -S' + @@servername<br/>EXEC master..xp_cmdshell @sql<br/><br/>-- Example query<br/>use TSQL2016;<br/>select 'Id', 'DateWrite', 'Euro', 'Brent'<br/>union all<br/>select cast(Id as varchar(100)), cast(DateWrite as varchar(100)), cast(Euro as varchar(100)), cast(Brent as varchar(100)) <br/>from Euro_Brent</pre><table border='1'><tr><th>Id</th><th>DateWrite</th><th>Euro</th><th>Brent</th></tr><tr><td>1</td><td>2017-12-15 10:00:00</td><td>69.3</td><td>63.42</td></tr><tr><td>2</td><td>2017-12-15 10:10:00</td><td>69.43</td><td>63.47</td></tr><tr><td>3</td><td>2017-12-15 10:20:00</td><td>69.49</td><td>63.46</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr><tr><td>39</td><td>2017-12-15 16:20:00</td><td>69.48</td><td>63.31</td></tr><tr><td>40</td><td>2017-12-15 16:30:00</td><td>69.48</td><td>63.35</td></tr></table><script>publish_date();</script><hr /><h3>Column name or number of supplied values does not match table definition.</h3><p>Если вы получаете данную ошибку, при этом соответствие столбцов соответствует исходной и вставляемой таблицам, используйте следующий синтаксис, чтобы избежать ее:</p><pre>select *into new_table_name from source_table_name where [date] between '20160101' and '20161231'</pre><script>publish_date();</script><hr /><h3>Как удалить активные процессы всех пользователей ?.</h3><pre>declare @dbname varchar(100)<br />declare @query varchar(max)<br />set @query = ''<br />set @dbname = 'db_name'<br />select @query = coalesce(@query, ',') + 'kill ' + convert(varchar, spid) + '; '<br />from sys.sysprocesses where dbid = db_id(@dbname)<br />if len(@query) > 0 begin<br />	exec(@query)<br />end</pre><script>publish_date();</script><hr /><h3>Лучшие практики.</h3><p>Лучшее что я мог видеть.</p><pre>declare @i int = 365;<br />select power(0.99, @i) [min_motivation], power(1.01, @i) [max_motivation]</pre><p><b>Результат:</b></p><table border='1'><tr><th>min_motivation</th><th>max_motivation</th></tr><tr><td>0.03</td><td>37.78</td></tr></table><script>publish_date();</script><hr /><h3>Максимальное значение типа данных bigint.</h3><p>Как получить максимальное значение типа bigint:</p><pre>select power(2., 64) - 1 as maxValueBigInt</pre><script>publish_date();</script><hr /><h3>Смещение строк.</h3><p>Если вы хотите пропустить <b>n</b>-е число записей и получить следующие <b>m</b> записей, используйте следующий синтаксис:</p><pre>declare @n int = 0;<br />declare @m int = 5;<br />select *from (<br />	values (0), (1), (2), (3), (4), (5), (6), (7), (8), (9), (10), (11), (12), (13), (14), (15), (16), (17), (18), (19), (20)<br />) as t(id)<br />order by id<br />offset @n rows fetch first @m rows only</pre><script>publish_date();</script><hr /><h3>Unpivot:</h3><p>Если вам нужно сделать транспонирование (строки, заменить столбцами) таблицы, возьмите следующий код в качестве примера и используйте оператор <b>PIVOT</b>. Для обратной реализации транспозиции (столбцы заменить строками) используется оператор <b>UNPIVOT</b>.</p><pre>select IdKey, [Type], summ, [01], [02], [03], [04], [05], [06], [07], [08], [09], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31]<br />from (<br />	values(1, 'TYPE', 10.125, 198.3905194, 198.3905194, 332.8376936, 347.1834089, 459.8195238, 339.3698885, 521.4020027, 186.6064438, 349.5779158, 468.5718135, 466.1038878, 466.1038878, 477.7564851, 498.1261596, 201.9377443, 486.0331927, 545.2503678, 452.2873126, 512.7663862, 549.3981369, 462.8785397, 391.3860639, 595.2856341, 396.8570894, 595.2856341, 595.2856341, 541.3424301, 594.5881906, 396.8570894, 575.4633152, 396.8570894)<br />) as t(IdKey, [Type], summ, [01], [02], [03], [04], [05], [06], [07], [08], [09], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31])<br /><br /></pre><p><b>Результат</b></p><table border='1'><tr><th>IdKey</th><th>Type</th><th>summ</th><th>01</th><th>...</th><th>31</th></tr><tr><td>1</td><td>TYPE</td><td>10.125</td><td>198.390</td><td>...</td><td>396.857</td></tr></table><br /><pre>declare @date date = getdate();<br />select IdKey, [Type], concat(FORMAT(@date, 'yyMM'), DateKey) DateKey, Quantity, Summ<br />from (<br />	values(1, 'TYPE', 10.125, 198.390, 198.390, 332.837, 347.183, 459.819, 339.369, 521.402, 186.606, 349.577, 468.571, 466.103, 466.103, 477.756, 498.126, 201.937, 486.033, 545.250, 452.287, 512.766, 549.398, 462.878, 391.386, 595.285, 396.857, 595.285, 595.285, 541.342, 594.588, 396.857, 575.463, 396.857)<br />) as t(IdKey, [Type], summ, [01], [02], [03], [04], [05], [06], [07], [08], [09], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31])<br />UNPIVOT (<br />    Quantity<br />    FOR DateKey IN ([01], [02], [03], [04], [05], [06], [07], [08], [09], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31])<br />) UNPIV<br />order by IdKey</pre><p><b>Результат</b></p><table border='1'><tr><th>IdKey</th><th>Type</th><th>DateKey</th><th>Quantity</th><th>Summ</th></tr><tr><td>1</td><td>TYPE</td><td>171001</td><td>198.390</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171002</td><td>198.390</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171003</td><td>332.837</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171004</td><td>347.183</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171005</td><td>459.819</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171006</td><td>339.369</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171007</td><td>521.402</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171008</td><td>186.606</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171009</td><td>349.577</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171010</td><td>468.571</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171011</td><td>466.103</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171012</td><td>466.103</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171013</td><td>477.756</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171014</td><td>498.126</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171015</td><td>201.937</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171016</td><td>486.033</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171017</td><td>545.250</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171018</td><td>452.287</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171019</td><td>512.766</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171020</td><td>549.398</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171021</td><td>462.878</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171022</td><td>391.386</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171023</td><td>595.285</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171024</td><td>396.857</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171025</td><td>595.285</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171026</td><td>595.285</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171027</td><td>541.342</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171028</td><td>594.588</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171029</td><td>396.857</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171030</td><td>575.463</td><td>10.125</td></tr><tr><td>1</td><td>TYPE</td><td>171031</td><td>396.857</td><td>10.125</td></tr></table><script>publish_date();</script><hr /><h3>Преобразование MDX запроса в плоскую таблицу.</h3><p>Как развернуть mdx запрос в плоскую таблицу ?.</p><pre>DECLARE @query VARCHAR(MAX);<br />DECLARE @mdxquery VARCHAR(MAX);<br /><br />SET @mdxquery = ' YOUR_MDX_QUERY ';<br /><br />SET @query = '<br />	WITH MDX AS (<br />		SELECT<br />			ListColumns<br />		FROM OPENQUERY(YOUR_SERVER_NAME, ''' + @mdxquery + ''')<br />	)<br /><br />	SELECT ListColumns FROM MDX<br />';<br /><br />EXEC (@query);</pre><script>publish_date();</script><hr /><h3>Pivot:</h3><p>Как то не так давно, была поставлена задача. Необходимо было написать скрипт на выборку сумм по продажам (sales) со следующими условиями:<br />1. Выводить суммы продаж за указанный пользователем период;<br />2. В строки выводить наименование товаров, сумму продаж за указанную дату, при этом т.к. период выборки может меняться, количество колонок в итоговом отчете заранее неизвестно.<br />3. Данные выводить без учета времени. <br />4. В итоговый запрос выводить колонки: Наименование товара, дата1, дата2 и т.д</p><pre>--Table [ref_goods]:<br />select *from (<br />	values<br />		(1, 'Ballpoint pen black'),<br />		(1, 'Ballpoint pen blue'),<br />		(1, 'Gel black handle'),<br />		(1, 'Gel pen blue'),<br />		(2, 'Pencil blue'),<br />		(2, 'Pencil green'),<br />		(2, 'Pencil Red')<br />) as ref_goods(id, good_name)<br /><br />--Insert into Table [sales]:<br />declare @StartDate datetime<br />declare @EndDate datetime<br />declare @Good int<br />declare @Amount numeric(18, 2)<br /><br />set @StartDate = '20120101'<br />set @EndDate = getdate()<br />set @Good = 1<br />set @Amount = 15.12<br /><br />while @StartDate < @EndDate begin<br />	insert into sales<br />	select @Good, @StartDate, @Amount<br /><br />	set @StartDate = dateadd(hour, 4, @StartDate)<br />	set @Good = case when @Good = 7 then 1 else @Good + 1 end<br />	set @Amount = case when @Amount > 100000 then 15.12 else @Amount + 21.14 end<br />end<br /><br />--Strictly speaking, the request itselfset language british;<br />declare @StartDate datetime = '20120101';<br />declare @EndDate datetime = getdate();<br /><br />declare @cols nvarchar(max)<br />select @cols = coalesce(@cols + ',[' + convert(nvarchar, s_date, 104) + ']', '[' + convert(nvarchar, s_date, 104) + ']')<br />			   from (select distinct cast(s_date as date) s_date from sales where s_date between @StartDate and @EndDate) PV<br />			   order by s_date<br /><br />declare @query nvarchar(max)<br />set @query = '<br />				select *from (<br />					select r.good_name, sum(s.amount) [amount], cast(s_date as date) s_date<br />					from sales s<br />						join ref_goods r on s.id_good = r.id<br />					where s_date between ''' + convert(nvarchar, @StartDate, 104) + ''' and ''' + convert(nvarchar, @EndDate, 104) + '''<br />					group by r.good_name, s_date<br />				) x<br />				pivot (<br />					sum(amount)<br />					for s_date in (' + @cols + ')<br />				) p<br />			'<br /><br />exec SP_EXECUTESQL @query</pre><script>publish_date();</script><hr /><h3>Что такое индекс в T-SQL ?.</h3><p>Индекс - это объект базы данных, созданный для повышения производительности поиска данных. Индекс похож на алфавитный указатель в книге. Если нам нужно найти определение функции в T-SQL, мы сделаем следующее:<br /><br />1. Найдём алфавитный указатель в книге (обычно в конце книги);<br />2. Затем найдём нужную функцию, например 'string_split', которая находится на странице 52;<br />3. После, перейдем на эту страницу и прочитаем все необходимое о данной функции.<br /><br />Индексы группируются и некластеризованы.</p><script>publish_date();</script><hr /><h3>Оптимизация запроса.</h3><p>Имеются два запроса, результат выборки один и тот же.<br />Один из них выполняется за 40 секунд, а другой - за 4 секунды, в чем подвох ?. Смотрим ниже:<br /><br /><b>Запрос:</b></p><pre>select <br />	isnull(_all.rdc, plans.rdc) rdc, <br />	isnull(_all.distributor, '') distributor, <br />	isnull(_all.sv, '') sv, <br />	isnull(_all.etp, '') etp, <br />	isnull(_all.subject, plans.subject) subject, <br />	isnull(_all.cnt_all, 0) cnt_all, <br />	isnull(_period.cnt_period, 0) cnt_period, <br />	isnull(plans.pln,0) reestr_tt <br />from (<br />	select rdc, distributor, sv, etp, subject, count(id) cnt_all from #TT<br />	where isnull(@rdc, rdc) = rdc <br />	and isnull(@subject, subject) = subject<br />	and distributor = isnull(@company, distributor)<br />	group by rdc, distributor, sv, etp, subject<br />) _all join (<br />	select rdc, distributor, sv, etp, subject, count(id) cnt_period from #TT<br />	where dtCreate between isnull(@beginDate, '19000101') and isnull(@endDate, '21500101')<br />	and isnull(@rdc, rdc) = rdc <br />	and isnull(@subject, subject) = subject<br />	and distributor = isnull(@company, distributor)<br />	group by rdc, distributor, sv, etp, subject<br />) _period<br />on <br />	_all.distributor = _period.distributor and <br />	_all.etp = _period.etp and<br />	_all.subject = _period.subject and<br />	_period.sv = _all.sv<br />right join (<br />	select upl.rdc, p.subject, sum(p.count) pln from<br />	ReportPlan p join (select distinct rdc, subject from upload where isnull(@rdc, rdc) = rdc and isnull(@subject, subject) = subject) upl on p.subject = upl.subject and upl.rdc is not null<br />	group by upl.rdc, p.subject<br />) plans on plans.subject = _all.subject<br />order by _all.rdc, _all.subject<br /></pre><p><b>Результат:</b></p><pre>SQL Server Execution Times:			CPU time = 0 ms,  elapsed time = 0 ms.<br />SQL Server parse and compile time:  		CPU time = 859 ms, elapsed time = 950 ms.<br />SQL Server Execution Times:			CPU time = 0 ms,  elapsed time = 0 ms.<br /><br />(1026 row(s) affected)<br />Table 'Workfile'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br />Table 'Worktable'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br />Table 'ReportPlan'. Scan count 1, logical reads 144, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br />Table 'upload'. Scan count 1, logical reads 745, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br />Table '#TT'. Scan count 2, logical reads 1524, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br /><br />(1 row(s) affected)<br /><br />SQL Server Execution Times:			CPU time = 23188 ms,  elapsed time = 45460 ms.<br />SQL Server parse and compile time:		CPU time = 0 ms, elapsed time = 0 ms.<br />SQL Server Execution Times:			CPU time = 0 ms,  elapsed time = 0 ms.<br /></pre><p><b>Оптимизированный запрос:</b></p><pre>select <br />	isnull(_all.rdc, plans.rdc) rdc, <br />	_all.distributor, <br />	_all.sv, <br />	_all.etp, <br />	isnull(_all.subject, plans.subject) subject, <br />	_all.cnt_all, <br />	_period.cnt_period, <br />	plans.pln reestr_tt <br />from (<br />	select upl.rdc, p.subject, sum(p.count) pln from<br />	ReportPlan p join (<br />		select distinct rdc, subject from sensus_etp_upload where isnull(@rdc, rdc) = rdc and isnull(@subject, subject) = subject<br />	) upl on p.subject = upl.subject and upl.rdc is not null<br />	group by upl.rdc, p.subject<br />) plans left join (<br />	select rdc, distributor, sv, etp, subject, count(id) cnt_all from #TT<br />	where isnull(@rdc, rdc) = rdc <br />	and isnull(@subject, subject) = subject<br />	and distributor = isnull(@company, distributor)<br />	group by rdc, distributor, sv, etp, subject<br />) _all on plans.subject = _all.subject<br />left join (<br />	select rdc, distributor, sv, etp, subject, count(id) cnt_period from #TT<br />	where dtCreate between isnull(@beginDate, '19000101') and isnull(@endDate, '21500101')<br />	and isnull(@rdc, rdc) = rdc <br />	and isnull(@subject, subject) = subject<br />	and distributor = isnull(@company,distributor)<br />	group by rdc, distributor, sv, etp, subject<br />) _period<br />on <br />	_all.distributor = _period.distributor and <br />	_all.etp = _period.etp and<br />	_all.subject = _period.subject and<br />	_period.sv = _all.sv<br />order by _all.rdc, _all.subject<br /></pre><p><b>Результат:</b></p><pre>SQL Server Execution Times:			CPU time = 0 ms,  elapsed time = 0 ms.<br />SQL Server parse and compile time:		CPU time = 843 ms, elapsed time = 849 ms.<br />SQL Server Execution Times:			CPU time = 0 ms,  elapsed time = 0 ms.<br /><br />(995 row(s) affected)<br />Table 'Worktable'. Scan count 156, logical reads 6600, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br />Table '#TT'. Scan count 2, logical reads 1556, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br />Table 'upload'. Scan count 1, logical reads 1471, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br />Table 'ReportPlan'. Scan count 1, logical reads 144, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<br /><br />(1 row(s) affected)<br /><br />SQL Server Execution Times:			CPU time = 2172 ms,  elapsed time = 2660 ms.<br />SQL Server parse and compile time:		CPU time = 0 ms, elapsed time = 0 ms.<br />SQL Server Execution Times:			CPU time = 0 ms,  elapsed time = 0 ms.</pre><script>publish_date();</script><hr /><h3>Перенос DistinctBy на T-SQL.</h3><p>На данный момент я разрабатываю и поддерживаю проект типа MVC, и мне часто приходится иметь дело с переписыванием кода C# на T-SQL. Например, сегодня рассмотрим метод C# DistinctBy(). Я взял массив данных из прошлой статьи:</p><pre>// C#<br />data.DistinctBy(x => x.TmId).OrderBy(x => x.Points)<br /><br />// T-SQL<br />select *from(<br />	select Rm as Employee, (OutPoint + IncrementPoint + ArkbPoint + SdzPoint + RoutePoint + SchedulePoint) / 6 as ball, row_number() over (partition by RmId order by Id) rn from #tmp<br />) t where rn = 1</pre><script>publish_date();</script><hr /><h3>Перенос LinqToSql на T-SQL.</h3><p>Всем хорошего дня, недавно я столкнулся с задачей переписать linq в t-sql, все было бы хорошо, но было одно но: нам пришлось переписать метод C# Array.FindIndex() на T-SQL. Реализация ниже:</p><pre>// C#<br />List<Rating2> data =<br />	Context.Rating.Where(x => x.CreatedDate.Month == date.Month && x.CreatedDate.Year == date.Year && x.CreatedDate.Day == date.Day).ToList();<br /><br />List<Rating> ratings = data.Select(<br />	x => new Rating<br />	{<br />		Id = x.Id,<br />		Rdc = x.Rdc,<br />		RdcId = x.RdcId,<br />		Distributor = x.Distributor,<br />		DistributorId = x.DistributorId,<br />		EtpId = x.EtpId,<br />		Etp = x.Etp,<br />		RmId = x.RmId,<br />		Rm = x.Rm,<br />		Sv = x.Sv,<br />		SvId = x.SvId,<br />		Tm = x.Tm,<br />		TmId = x.TmId,<br />		OutPoint = 2 * (Array.FindIndex(data.OrderByDescending(o => o.OutMass).ToArray(), a => a.EtpId == x.EtpId) + 1),<br />		IncrementPoint = 2 * (Array.FindIndex(data.OrderByDescending(o => o.PrevOutMass).ToArray(), a => a.EtpId == x.EtpId) + 1),<br />		ArkbPoint = Array.FindIndex(data.OrderByDescending(o => o.CountAtt).ToArray(), a => a.EtpId == x.EtpId) + 1,<br />		SdzPoint = Array.FindIndex(data.OrderByDescending(o => o.AvgOrdersPerDay).ToArray(), a => a.EtpId == x.EtpId) + 1,<br />		RoutePoint = Array.FindIndex(data.OrderByDescending(o => o.PenaltyRoute).ToArray(), a => a.EtpId == x.EtpId) + 1,<br />		SchedulePoint = Array.FindIndex(data.OrderByDescending(o => o.PenaltyWorktime).ToArray(), a => a.EtpId == x.EtpId) + 1,<br />		ObservanceRoute = x.PenaltyRoute,<br />		MaintenanceSchedule = x.PenaltyWorktime,<br />		Sdz = x.AvgOrdersPerDay,<br />		FactOutLast = x.PrevOutMass,<br />		PlanPercentArkb = x.CountAtt,<br />		FactOut = x.FactOut,<br />		PlanOut = x.PlanOut,<br />		FactArkb = x.FactArkb,<br />		PlanArkb = x.PlanArkb,<br />		PlanPercentOut = x.OutMass,<br />		IncrementRate = x.IncrementRate<br />}).ToList();<br /><br />// T-SQL<br />select<br />	Id,<br />	Rdc,<br />	RdcId,<br />	Distributor,<br />	DistributorId,<br />	EtpId,<br />	Etp,<br />	RmId,<br />	Rm,<br />	Sv,<br />	SvId,<br />	Tm,<br />	TmId,<br />	2 * cast(row_number() over(order by OutMass desc, Id) as int) OutPoint,<br />	2 * cast(row_number() over(order by PrevOutMass desc, Id) as int) IncrementPoint,<br />	cast(row_number() over(order by CountAtt desc, Id) as int) ArkbPoint,<br />	cast(row_number() over(order by AvgOrdersPerDay desc, Id) as int) SdzPoint,<br />	cast(row_number() over(order by PenaltyRoute desc, Id) as int) RoutePoint,<br />	cast(row_number() over(order by PenaltyWorktime desc, Id) as int) SchedulePoint,<br />	PenaltyRoute as ObservanceRoute,<br />	PenaltyWorktime as MaintenanceSchedule,<br />	AvgOrdersPerDay as Sdz,<br />	PrevOutMass as FactOutLast,<br />	CountAtt as PlanPercentArkb,<br />	FactOut,<br />	PlanOut,<br />	FactArkb,<br />	PlanArkb,<br />	OutMass as PlanPercentOut,<br />	IncrementRate<br />from Rating<br />where isnull(@load_date, CreatedDate) = CreatedDate<br />order by Id</pre><script>publish_date();</script><hr /><h3>Null value is eliminated by an aggregate or other SET operation.</h3><p>Полученная ошибка появлялась временами в хранимых процедурах. Пример показал, как вы можете избавиться от нее.</p><pre>--Before:<br />select sum(col2) sum_col2 from(<br />	select *from (<br />		values<br />			( 1, NULL, 3 ),<br />            ( 1, 2, 3 )<br />	) as d(col1, col2, col3)<br />) t<br /><br /><b>Результат:</b><br />sum_col2<br />2<br />Warning: Null value is eliminated by an aggregate or other SET operation.<br />(1 row(s) affected)<br /><br />--After:<br />select sum(isnull(col2, 0)) sum_col2 from(<br />	select *from (<br />		values<br />			( 1, NULL, 3 ),<br />            ( 1, 2, 3 )<br />	) as d(col1, col2, col3)<br />) t<br /><br /><b>Результат:</b><br />sum_col2<br />2<br />(1 row(s) affected)</pre><script>publish_date();</script><hr /><h3>Задания.</h3><p>В данной статье я хотел бы привести пример запроса, который отображает список всех заданий относительно желаемого имени таблиц, представлений, хранимых процедур, функций и многих других объектов sql.</p><pre>select name [JobName], step_name, *<br />from msdb.dbo.sysjobsteps s<br />	join msdb.dbo.sysjobs o on o.job_id = s.job_id<br />where command like '%contains%'</pre><p>Запрос «содержит» - ваши данные для поиска (это могут быть либо таблицы, либо процедуры, а также функции и другие объекты sql). Ниже приведен пример запроса, который возвращает реальные данные.</p><pre>select name [JobName], step_name, *<br />from msdb.dbo.sysjobsteps s<br />	join msdb.dbo.sysjobs o on o.job_id = s.job_id<br />where command like '%server%'<br /></pre><script>publish_date();</script><hr /><h3>Импорт и экспорт данных.</h3><p>В этой статье я хочу поделиться с вами опытом экспорта данных из Excel в MS SQL SERVER<br /><br />Предположим, что существует пустая таблица dbo.Coords.<br />Также есть файл Excel с некоторыми данными.<br />Сначала запустите «Импорт и экспорт данных сервера Sql», выберите «Местоположение файла» в раскрывающемся списке <b>Источник данных</b>: «Microsoft Excel» в записи пути к файлу <b>Excel</b>.<br />В поле <b>Назначение</b>: выберите «Собственный клиент SQL Server 11.0», выберите базу данных из списка ...<br />Скопируйте данные из файла Excel в таблицу, указанную на следующем шаге.<br />Файл Excel называется Coords.xlsx, таблица называется dbo.Coords.<br />Посмотрим, правильно ли мы выбрали все.<br />И начнем, пожалуй.<br />Экспорт завершен.<br />Не забудьте проверить, что данные в таблице dbo.Coords обновлены.</p><script>publish_date();</script><hr /><h3>База данных по умолчанию.</h3><p>Часто при подключении к компоненту DataBase Engine по умолчанию устанавливается база данных «master». Исправить данную ситуацию мы можем следующим образом:</p><pre>[Файл] -> [Подключиться к базе данных] -> [Опции >>] -> На вкладке [Подключение к] выберите [&lt;Обзор сервера ...&gt;] -> Ответьте утвердительно, чтобы посмотреть базы данных -> И выберите из списка требуемую базу данных.</pre><script>publish_date();</script><hr /><h3>Блокировки.</h3><p>На одном из этапов своей карьеры разработчика вы можете начать использовать хинт WITH (NOLOCK) повсеместно, поскольку с ним ваши запросы выполняются быстрее. Это не всегда плохо, но может сопровождаться неожиданными побочными эффектами. Я же сфокусируюсь только на одном из них. Когда ваш запрос обращается к какой-либо таблице, даже с хинтом NOLOCK, вы накладываете блокировку стабилизации схемы (schema stability lock, Sch-S). Никто не сможет изменить эту таблицу или её индексы до тех пор, пока ваш запрос не завершится. Это не кажется серьёзной проблемой до тех пор, пока вам не понадобится удалить индекс, но вы не сможете этого сделать, поскольку люди постоянно работают с этой таблицей, находясь в полной уверенности, что не создают никаких проблем, поскольку они используют хинт WITH (NOLOCK). Здесь нет «серебряной пули», но начните читать об уровнях изоляции SQL Server — я полагаю, что уровень изоляции READ COMMITTED SNAPSHOT будет наилучшим выбором для вашего приложения. Вы будете получать целостные данные с меньшим количеством проблем с блокировками.</p><script>publish_date();</script><hr /><h3>IntelliSense.</h3><p>На днях я заметил, что IntelliSense не работает в sqlms 2014.<br />Он перестал работать из-за удаления sql Assistant.<br /><br />Эта проблема решается очень легко:</p><pre>Выберите: Интсрументы -> Опции -> Текстовый редактор -> Transact-SQL -> IntelliSense -> Включить IntelliSense</pre><script>publish_date();</script><hr /><h3>Кубы.</h3><p>Чтобы подключиться к системе анализа информации OLAP, вам необходимо выполнить следующие шаги:<br />1. Запустите продукт Microsoft Excel, входящий в комплект Microsoft Office.<br />2. В меню Excel перейдите на вкладку «Данные».<br />3. На панели «Получить внешние данные» выберите «Из других источников» - «Из служб аналитики».<br />4. В появившемся диалоговом окне в поле «Имя сервера» введите имя сервера: «your-server-name». Оставьте остальные параметры неизменными. Нажмите кнопку «Далее».<br />5. В диалоговом окне «Мастер подключения к данным» вы должны выбрать базу данных «your_db_name» на панели выбора куба - куб «your_cube_name». Нажмите 'Далее'.<br />6. В диалоговом окне «Сохранить соединение с данными и завершение работы» согласитесь с предлагаемыми вариантами и нажмите «Готово».<br />7. В диалоговом окне «Импорт данных» вы можете выбрать любую ячейку листа Excel. Нажмите кнопку «ОК».<br />8. Интерфейс с аналитической системой «your_cube_name» является стандартным интерфейсом Microsoft Excel для работы со сводными таблицами. Область самого сводного отчета отображается в левом углу.</p><script>publish_date();</script><hr /><h3>Деревья.</h3><p>Пример дерева в t-sql.<br />Я напишу следуюший запрос, а затем попытайтесь понять, что он делает, <a href='mailto:hru91nik@mail.ru'>сюда</a> вы можете отправлять свои комментарии.<br />Код показан ниже.</p><pre>with Employees as (<br />	select *from (<br />		values<br />		   (1,  NULL, 'David'  , $10000.00),<br />		   (2,  1,    'Eitan'  ,  $7000.00),<br />		   (3,  1,    'Ina'    ,  $7500.00),<br />		   (4,  2,    'Seraph' ,  $5000.00),<br />		   (5,  2,    'Jiru'   ,  $5500.00),<br />		   (6,  2,    'Steve'  ,  $4500.00),<br />		   (7,  3,    'Aaron'  ,  $5000.00),<br />		   (8,  5,    'Lilach' ,  $3500.00),<br />		   (9,  7,    'Rita'   ,  $3000.00),<br />		   (10, 5,    'Sean'   ,  $3000.00),<br />		   (11, 7,    'Gabriel',  $3000.00),<br />		   (12, 9,    'Emilia' ,  $2000.00),<br />		   (13, 9,    'Michael',  $2000.00),<br />		   (14, 9,    'Didi'   ,  $1500.00)<br />	) as d(empid, mgrid, empname, salary)<br />),<br />EmpsRN as (<br />	select *, row_number() over(partition by mgrid order by empname, empid) as n<br />	from Employees<br />),<br />EmpsPath as (<br />	 select empid, empname, salary, 0 AS lvl, cast(0x as varbinary(max)) as sortpath<br />	 from Employees<br />	 where mgrid is null<br />	 union all<br />	 select C.empid, C.empname, C.salary, P.lvl + 1, P.sortpath + cast(n as binary(2))<br />	 from EmpsPath as P<br />		join EmpsRN as C on C.mgrid = P.empid<br />)<br />select empid, salary, replicate(' | ', lvl) + empname as empname<br />from EmpsPath<br />order by sortpath;<br /></pre><p>Пример взят из книги Итцик Бен-Гана «Microsoft SQL Server 2012. Высокопроизводительный код T-SQL. Оконные функции». </p><script>publish_date();</script><hr /><h3>Оконные функции.</h3><p>Плюсы оконных функций.<br />Я не буду здесь ничего комментировать, просто посмотрите на следующий код, и вы сами все поймете. Если у вас все еще остались вопросы, вы можете адресовать их мне по этому <a href='mailto:hru91nik@mail.ru'>адресу</a>.<br />Ниже перечислены как альтернативы, так и оконные функции.</p><pre>-- 1.1. without window func<br />with CustAggregates as(<br />	select custid, sum(val) as sumval, avg(val) as avgval<br />	from Sales.OrderValues<br />	group by custid<br />),<br />GrandAggragates as(<br />	select sum(val) as sumval, avg(val) as avgval<br />	from Sales.OrderValues<br />)<br />select o.orderid, o.custid, o.val,<br />	cast(100 * o.val / ca.sumval as numeric(5, 2)) as pctcust,<br />	o.val - ca.avgval as diffcust,<br />	cast(100 * o.val / ga.sumval as numeric(5, 2)) as pctall,<br />	o.val - ga.avgval as diffall<br />from Sales.OrderValues as o<br />	join CustAggregates as ca on o.custid = ca.custid<br />	cross join GrandAggragates as ga;<br /><br />-- 1.2. without window func<br />select orderid, custid, val,<br />	cast(100 * val / (<br />		select sum(o2.val)<br />		from Sales.OrderValues as o2<br />		where o2.custid = o1.custid<br />  ) as numeric(5, 2)) as pctcust,<br />	val - (<br />		select avg(o2.val)<br />		from Sales.OrderValues as o2<br />		where o2.custid = o1.custid<br />  ) diffcust,<br />	cast(100 * val / (<br />		select sum(o2.val)<br />		from Sales.OrderValues as o2) as numeric(5, 2)) as pctall,<br />	val - (<br />		select avg(o2.val)<br />		from Sales.OrderValues as o2<br />		where o2.custid = o1.custid<br />  ) diffall<br />from Sales.OrderValues as o1<br /><br />-- 1.3. with window func<br />select orderid, custid, val,<br />	cast(100 * val / sum(val) over(partition by custid) as numeric(5, 2)) as pctcust,<br />	val - avg(val) over(partiotion by custid) diffcust,<br />	cast(100 * val / sum(val) over() as numeric(5, 2)) as pctall,<br />	val - avg(val) over() diffall<br />from Sales.OrderValues;<br /><br />-- 1.4. without window func<br />select min(col1) as start_range, max(col1) as end_range<br />from (<br />	select col1,(<br />		select min(b.col1)<br />		from dbo.T1 as b<br />		where b1.col1 >= a.col1<br />			and not exists(<br />			select *<br />			from dbo.T1 as c<br />			where c.col1 = b.col1<br />		)<br />	) as grp<br />	from dbo.T1 as a<br />) as d<br />group by grp;<br /><br />-- 1.5. with window func<br />select min(col1) as start_range, max(col1) as end_range<br />from (<br />	select col1,<br />	col1 - row_number() over(order by col1) as grp<br />	from dbo.T1<br />) as d<br />group by grp;</pre><script>publish_date();</script><hr /><h3>Запрос с двумя или более серверами.</h3><p>На днях упала задача, как объединить две таблицы с разных серверов. Итак, на t-sql проблема была решена следующим образом:</p><pre>select *from [srvName].[dbName].[shemaName].[tableName]<br />union all<br />select *from [srvNameOld].[dbName].[shemaName].[tableName]</pre><p>Таким образом, мы получаем набор результатов с двух разных серверов, стоит отметить, что таблицы в моем случае идентичны.</p><script>publish_date();</script><hr /><h3>For xml path.</h3><p>В этой статье я хотел бы поделиться с вами следующим инструментом. Предположим, что существует запрос, представленный следующим кодом</p><pre>with T1 as (<br />	select *from (<br />		values<br />			(1, 'A'),<br />			(2, 'B'),<br />			(3, 'C'),<br />			(4, 'D'),<br />			(5, 'E')<br />	) as d(id, word)<br />) select *from T1</pre><p>Запрос имеет следующий вид</p><pre>select *from T1;</pre><p>Задача состоит в том, чтобы собрать строки в одном поле, например, для поля «word», результат должен быть следующим: «A, B, C, D, E». В t-sql существует следующая конструкция: <b>for xml path('')</b>. Нам будет необходимо получить этот результат. Запрос будет выглядеть следующим образом:</p><pre>select word + ', ' from T1 for xml path('');</pre><script>publish_date();</script>
			
			<script>foo();</script>
		</div>
	</body>
</html>